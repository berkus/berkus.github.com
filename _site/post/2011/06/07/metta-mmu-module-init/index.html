<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Exocortex by berkus</title>

    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/pygment_trac.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />
    <script src="/javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="/">Exocortex</a></h1>
        <p><a href="/about.html">scribbling for singularity</a></p>
      </header>
      <section>
       <h3>MMU initialisation</h3>

<p>First off, we start by loading the needed modules - mmu_mod, frames_mod and heap_mod.</p>

<p>mmu_mod will allocate and map the first chunk of memory to use. It does so without knowing much about memory allocation - just takes a first fit chunk from the physical memory map, passed to us by the bootloader. Parts of this memory will be used by frames_mod and heap_mod as well, so we need a way to know how much memory they would need.</p>

<p>We need frames_mod to tell us, how much it needs to manage the physical memory, for the heap we just assume some size that we would need dynamically during rest of startup.</p>

<div class="highlight"><pre><code class="c"><span class="kt">int</span> <span class="n">required</span> <span class="o">=</span> <span class="n">frames_mod</span><span class="o">-&gt;</span><span class="n">required_size</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">initial_heap_size</span> <span class="o">=</span> <span class="mi">128</span><span class="o">*</span><span class="n">KiB</span><span class="p">;</span>
</code></pre></div>


<p>How frames module figures out its required space we will understand in a moment, when we see the structures it uses for bookkeeping.</p>

<p>With space requirements in our hands we can start initialising MMU structures.</p>

<p>MMU state is pretty large, it consists of page directory and page tables used for initial mappings, RAM table and some important closures - system frame allocator, heap and stretch allocator, as well as ramtab closure.</p>

<p>MMU create method will initialise all these structures in one big chunk of memory allocated from physical memory map. It also means this data may overwrite some of the information loaded by grub (namely the bootimage), but weʼve already copied everything we need higher in memory while loading the modules, so this is fine.</p>

<p>After allocating all page structures, we will fill them up by means of enter_mappings() function. This function will cover allocated memory and also allocate extra L2 page tables. Finally, all important pointers are set up and the CPU is switched to the newly allocated page directory.</p>

<p>Next step is to create the physical frame allocator.</p>

<h3>Frame allocator initialisation</h3>

<p>Frame allocator needs to track all frames of physical memory, their availability and ownership.</p>

<p>It does so by keeping a linked list of allocation regions (which roughly correspond to areas in the BIOS memory map passed to us). Each region entry has a list of frames in this region and their availability.</p>

<div class="highlight"><pre><code class="c"><span class="k">struct</span> <span class="n">frames_module_v1_state</span>
<span class="p">{</span>
    <span class="kt">address_t</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">n_logical_frames</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">frame_width</span><span class="p">;</span>
    <span class="n">memory_v1_attrs</span> <span class="n">attrs</span><span class="p">;</span>
    <span class="n">ramtab_v1_closure</span><span class="o">*</span> <span class="n">ramtab</span><span class="p">;</span>
    <span class="n">frames_module_v1_state</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="n">frame_st</span><span class="o">*</span> <span class="n">frames</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>


<p>Each region starts at address “start” and lasts for “n_logical_frames”, each of 2<sup>frame_width</sup> bytes in size. Memory in this region has attributes “attrs” and if this is RAM, it has an associated “ramtab”.</p>

<p>“next” points to the next region in the list and “frames” points to an array of n_logical_frames entries describing which frames are free. This array consists of very simple entries:</p>

<div class="highlight"><pre><code class="c"><span class="k">struct</span> <span class="n">frame_st</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">free</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>


<p>The “free” member indicates how many frames starting from a given frame index are free. Zero means this frame is occupied, any N above zero means that this frame, and N-1 frames after it are available.</p>

<p>It makes it fairly easy to look for the first-fit or the best-fit frame stretches. On the downside you need to update multiple frames at once if you allocate some frames at the end, so the best strategy for physical memory allocation is to allocate frames at the start (just set the value of “free” to 0) and to release them from end to start (so the last frame of the freed region takes value of “free” from the next frame plus one, and so on).</p>

<p>Frame allocator also keeps track of domains that request frame allocation, or clients.
For each new client, thereʼs a structure describing it and the contract obligations that frame allocator has for this client.</p>

<div class="highlight"><pre><code class="c"><span class="k">struct</span> <span class="n">frame_allocator_v1_state</span>
<span class="p">{</span>
    <span class="n">frame_allocator_v1_closure</span> <span class="n">closure</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">n_allocated_phys_frames</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">owner</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">guaranteed_frames</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">extra_frames</span><span class="p">;</span>
    <span class="n">heap_v1_closure</span><span class="o">*</span> <span class="n">heap</span><span class="p">;</span>
    <span class="n">frames_module_v1_state</span><span class="o">*</span> <span class="n">module_state</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>


<p>This structure describes the owner (by storing its domain recordʼs physical address in “owner”), amount of already allocated frames, guaranteed total amount of frames that this client could allocate and amount of extra frames that client might receive if thereʼs no memory pressure. It also contains a pointer to the region list used to allocate frames in “module_state”. Multiple clients may point to the same list for memory allocation.</p>

<p>Whenever a frame is occupied and taken from that list, owner information is recorded inside the ramtab.</p>

<h3>The ramtab</h3>

<p>Ramtab registers ownership information for allocated frames, it also records if these frames are “nailed” - that is, cannot be unmapped or released.</p>

<div class="highlight"><pre><code class="c"><span class="k">struct</span> <span class="kt">ramtab_entry_t</span>
<span class="p">{</span>
    <span class="kt">address_t</span> <span class="n">owner</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">frame_width</span><span class="p">;</span>
    <span class="kt">uint16_t</span> <span class="n">state</span><span class="p">;</span>
<span class="p">}</span> <span class="n">PACKED</span><span class="p">;</span>
</code></pre></div>


<p>Thatʼs about all it does at the moment, so I wonʼt focus on it.</p>

<h3>The heap</h3>

<p>After all the above the heap looks fairly simplistic. Thereʼs a header record with pointers to about 40 free lists - for blocks of different sizes. These free lists provide means to quickly allocate blocks of approximately requested size (or “best fit”).</p>

<div class="highlight"><pre><code class="c"><span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">SMALL_BLOCKS</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">LARGE_BLOCKS</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">COUNT</span> <span class="o">=</span> <span class="p">(</span><span class="n">SMALL_BLOCKS</span> <span class="o">+</span> <span class="n">LARGE_BLOCKS</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">memory_v1_size</span> <span class="n">all_sizes</span><span class="p">[</span><span class="n">COUNT</span><span class="p">];</span>
<span class="kt">heap_rec_t</span><span class="o">*</span> <span class="n">blocks</span><span class="p">[</span><span class="n">COUNT</span><span class="p">];</span>
</code></pre></div>


<p>The structure is two-dimensional: free lists connect memory blocks through “next” pointers, while allocated blocks are connected by their physical adjacency.</p>

<p>Each block has a header:</p>

<div class="highlight"><pre><code class="c"><span class="k">struct</span> <span class="kt">heap_rec_t</span>
<span class="p">{</span>
    <span class="n">memory_v1_size</span> <span class="n">prev</span><span class="p">;</span>  <span class="c1">// either a magic or size of previous block (backlink).</span>
    <span class="n">memory_v1_size</span> <span class="n">size</span><span class="p">;</span>  <span class="c1">// size of allocated block, including the end footer.</span>
    <span class="kt">uint32_t</span>       <span class="n">index</span><span class="p">;</span> <span class="c1">// allocation table index.</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="kt">heap_t</span><span class="o">*</span> <span class="n">heap</span><span class="p">;</span> <span class="c1">// when busy</span>
        <span class="kt">heap_rec_t</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span> <span class="c1">// when free</span>
    <span class="p">};</span>
<span class="p">};</span>
</code></pre></div>


<p>The end footer of the block is actually the first field of the next block, which contains a previous block link in case the block is free (this makes free lists double-linked lists actually) or HEAP_MAGIC in case the block is occupied. Allocation table index allows for quick return of freed blocks into their corresponding free lists.</p>

<p>To allocate memory we round up requested block size to a minimum granularity we support (8 bytes in current implementation), then find index of a corresponding free list using find_index() call and look if thereʼs a free block available.</p>

<p>If it is - we set up some meta information (like the owning heap and the fact that the block is now used) and return.</p>

<p>If there isnʼt free block available - we take some space from the “all sizes” block, which is usually just huge chunk of still available memory.</p>

<p>This memory can get fragmented as well, and when thereʼs no more memory available heap must grow. The current “raw” heap does not support this, and it will be implemented for stretch-backed heaps later, when stretch allocator works - which is the topic for the next post. Stay tuned!</p>

<p>PDF version of <a href="http://downloads.exquance.com/mmu_init.pdf">MMU init is also available</a>.</p>


<a href="/">Back to start</a>

      </section>
      <div class="wrap_disqus">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          var disqus_shortname = 'exocortex';
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    </div>
    
    <footer>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a>.</p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-36158006-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

    <script type="text/javascript">
      var disqus_shortname = 'exocortex';
      (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
      }());
    </script>
  </body>
</html>
