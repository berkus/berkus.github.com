<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Exocortex by berkus</title>

    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/pygment_trac.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />
    <script src="/javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="/">Exocortex</a></h1>
        <p><a href="/about.html">scribbling for singularity</a></p>
      </header>
      <section>
       <p>I have cleaned up the booting mess more or less and now my loader is able to
enter the <strong>root domain</strong> - the startup component, which initialises all other
components in order and passes control on to userspace loader component, which
is supposed to finish system initialisation by starting up all user interface
services.</p>

<p>Now there are pretty many loaders here already - there's a first stage loader
which is either GRUB or some other kind of boot loader, next there is second
stage loader which understands boot protocol, be it multiboot or Linux-style
boot or something else and converts all information to format understood by
kernel startup, which in turn parses the info from bootinfo page and sets
necessary flags, configures necessary platform hardware, prepares memory
structures like IDT and GDT and then launches the root domain, which in turn
loads all startup modules, initialises them and passes control on to userspace
startup component. This is 5 startup stages in all.</p>

<p>Now the design decision in modular system with C++ implementation is
separation of component architecture and OO implementation. In component
system, nothing is known about component implementation outside of the
component and C++ implementation details break at component interface boundary
- we want to confine implementation details inside component and expose only a
C++ representation of public interface.</p>

<p>Therefore, C++ implementation breaks down to 3 essential parts: C++
implementation, in whatever level of detail we want, from very simple to
complex elaborate designs, this is invisible to client code. Second is a thin
C-style component interface layer. It is so thin, that I do not want to mess
with it manually and it is generated by the IDL stub compiler, <strong>meddler</strong>. It
is also able to generate the third piece - C++ wrapper around C interface that
can be used in appropriate way by C++ clients.</p>

<p>Since meddler is still in the works, I generated some C interfaces manually
for testing and now implement the memory management components behind those
interfaces. Seems to be fairly interesting, since in pre-component design the
C++ interfaces were directly exposed to client code and it was fairly easy to
change public interface by simply declaring new methods public or private. It
was also fairly easy to screw things up, because C++ exposes way too much to
clients by default. This is different in component world, you have to be
careful with how much of API you expose to clients - what is exposed once
remains with this version of interface and has to be supported. Thankfully, I
have versioned interfaces and this liability is not forever. On the bright
side, only what you exposed will be seen - this makes client interface much
thinner and cleaner.</p>

<p>Now on to MMU, frame allocator and stretch allocator implementations.</p>


<a href="/">Back to start</a>

      </section>
      <div class="wrap_disqus">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
          var disqus_shortname = 'exocortex';
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    </div>
    
    <footer>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a>.</p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-36158006-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

    <script type="text/javascript">
      var disqus_shortname = 'exocortex';
      (function () {
          var s = document.createElement('script'); s.async = true;
          s.type = 'text/javascript';
          s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
          (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
      }());
    </script>
  </body>
</html>
